\subsection{Интеграция расширений}
\label{sec:extention_interaction}

В мире .NET существует два пути реализации взаимодействия приложения с подключаемыми внешними модулями. Ниже рассматриваются оба этих подхода.

\subsubsection{.NET Reflection}

Рефлексивно-ориентированное программирование, или рефлексивное программирование — функциональное расширение парадигмы объектно-ориентированного программирования. Рефлексивно-ориентированное программирование включает в себя самопроверку, самомодификацию и самоклонирование. Тем не менее, главное достоинство рефлексивно-ориентированной парадигмы заключается в динамической модификации программы, которая может быть определена и выполнена в процессе выполнения. Некоторые императивные подходы, например, процедурная и объектно-ориентированная парадигмы программирования, указывают, что существует четкая предопределённая последовательность операций обработки данных. Парадигма рефлексивно-ориентированного программирования, тем не менее, добавляет возможность динамической модификации программных инструкций во время работы и их вызова в модифицированном виде. То есть программная архитектура сама определяет, что именно можно делать во время работы исходя из данных, сервисов и специфических операций.

Рефлексия может использоваться для наблюдения и изменения программы во время выполнения. Рефлексивный компонент программы может наблюдать за выполнением определённого участка кода и изменять себя для достижения желаемой цели. Модификация выполняется во время выполнения программы путём динамического изменения кода~\cite{cs2010-dotnet40}.

Рефлексию можно применять и для динамической адаптации программы к различным ситуациям. Например, рассмотрим программу, использующую два разных класса X и Y для выполнения аналогичных операций. Без рефлексии в коде программы методы классов X и Y будут вызываться явно. Если программа спроектирована с применением рефлексивно-ориентированный парадигмы программирования, некоторый участок кода не будет содержать явных вызовов методов классов X и Y; программа выполнит этот участок дважды: сначала для класса X, затем для класса Y.

Таким образом, рефлексия может быть использована для динамического создания связей между сборками на этапе выполнения программы. Связь может быть любой – подписка на события, вызов методов, обращение к полям класса. Более того, для реализации подобного механизма не нужно сильно менять код расширяемого приложения, так как большинство действий по привязке происходят через идентификаторы. Всё это и позволяет использовать {\it .NET Reflection} для реализации взаимодействия основного приложения и подключаемыми внешними модулями~\cite{addins2-article}.

\subsubsection{System.Addin}

Эта библиотека позиционируется компанией Microsoft, как основное средство интеграции поддержки плагинов в {\it .NET} приложения~\cite{addins1-article, dotnet-app-extensibility}. Подробнее возможности этой библиотеки были рассмотрены в разделе \ref{sec:system_addin}. Стоит добавить, что использование этого продукта вынуждает пользователя соответствующим образом адаптировать архитектуру приложения, или же руковотствоваться советами специалистов Microsoft, описанными в различных источниках, например, MSDN, при разработке архитектуры приложения с нуля. Также из-за многоуровневой архитектуры взаимодействия плагина и приложения, принятого в {\it System.Addin}, программисту требуется реализация различных программных структур, таких как обёртки, прокси-объекты, контракты данных и прочее~\cite{use-systemaddin-namespace}. Однако в случае реализации механизма расширений <<с нуля>> использование {\it System.Addin} более предпочтительно из-за ряда очевидных преимуществ:

\begin{itemize}
  \item более высокий уровень абстракции;
  \item безопасность приложения на этапе выполнения расшерений;
  \item динамическая загрузка и выгрузка расширений.
\end{itemize}

\paragraph{Вывод.}

Из этих двух технологий была выбрана технология {\it .NET Reflection}, так как требовалось обеспечить большую гибкость при меньшем вмешательстве во внутреннюю архитектуру и код существующего приложения. Это было продиктовано одним из требований к платформе, заключавшемся в как можно более простой интеграции её в уже существующие приложения.

\subsubsection{Описание используемого подхода}

Для организации взаимодействия был реализован механизм, хранящий коллекции ссылок на объекты расширяемого приложения, которые реализуют необходимый интерфейс и являются доступными для обращения к ним со стороны расширения, а также события которых могут быть обработаны расширением. В приложении реализован механизм <<слежения>> за <<фабриками>>, либо другими структурами, порождающими экземпляры интересующих нас <<разделяемых объектов>>, ссылки на которые сразу после создания попадают в соответствующие коллекции. Соответственно, удаление либо изменение состояния доступных объектов также отслеживается. Помимо этого объект, реализующий интерфейс общего доступа получает уникальный идентификатор, по которому он может быть доступен извне (из пользовательского расширения).

На стороне расширения реализованы <<точки доступа>> к каждому из объектов, предназначенные для того, чтобы модуль интеграции расширений смог соотнести <<виртуальный>> объект, используемый в коде расширения, с <<реальным>> объектом, с которым это расширение будет работать на самом деле после загрузки в адресное пространство приложения. Подробнее о реализации данного механихма будет написано в разделе \ref{sec:ext_entry_point}.

\pagebreak
